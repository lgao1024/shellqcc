#!/bin/bash
# ==============================================================================
# Script Name: qec.sh
# Description: Quantum ESPRESSO Calculation Automation & Workflow Manager
#
# Summary:
#   A comprehensive wrapper to automate Quantum ESPRESSO (QE) tasks.
#   It takes a primary input file (typically prepared via qei.sh) and performs
#   calculation workflows.
#
# Key Feature:
#   In-situ Parameter Generation: The script automatically generates default
#   input parameters for post-processing and advanced calculations (DOS,
#   Bands, etc.) based on the primary input, simplifying the transition
#   between calculation stages.
#
# Usage:
#   qec.sh [-h | --help]
#   qec.sh <INPUT.in>              # Runs default task (pw)
#   qec.sh <INPUT.in> <tasks...>   # Runs specified tasks in order
#
# Supported Tasks:
#   pw (default), dos, co, esp, hp, bands, w90, phonon, thermo, dry, all
#
# Version: 0.4.1 (2026-01-28)
# ==============================================================================

set -euo pipefail

SCRIPT_NAME=$(basename "$0")
VERSION="0.4.1"
DATE="2026-01-28"

# ---------- Helpers ----------
msg()  { printf "[qec] %s\n" "$*"; }
err()  { printf "[qec:ERROR] %s\n" "$*" >&2; exit 1; }
warn() { printf "[qec:WARN ] %s\n" "$*" >&2; }

print_help() {
  cat <<EOF
${SCRIPT_NAME} — QE Calculation Workflow v${VERSION} (${DATE})

DESCRIPTION
  Automates Quantum ESPRESSO calculations with in-situ parameter generation.
  Designed to work with input files generated by 'qei.sh'.

USAGE
  ${SCRIPT_NAME} <INPUT.in>             → Run 'pw' task (default)
  ${SCRIPT_NAME} <INPUT.in> [tasks...]  → Run specified tasks sequentially
  ${SCRIPT_NAME} -h | --help            → Show this help message

AVAILABLE TASKS
  pw      : Self-Consistent Field / Relax (pw.x)
  dos     : Density of States (dos.x)
  bands   : Band Structure (bands.x)
  co      : Optical Conductivity
  esp     : Electrostatic Potential
  hp      : Hubbard U (hp.x)
  w90     : Wannier90 Interface
  phonon  : Phonon Calculation (ph.x)
  thermo  : Thermodynamics (thermo_pw.x)
  dry     : Dry run / Input validation
  all     : Chain: pw -> dos -> co -> esp -> bands

EXAMPLES
  ${SCRIPT_NAME} prefix.scf.in
  ${SCRIPT_NAME} prefix.relax.in pw dos bands
EOF
}

have_func() { declare -F "$1" >/dev/null 2>&1; }

run_qe() {
  local task=$1 IN_FILE=$2
  case "$task" in
    pw)      have_func calc_pw      && { msg "→ calc_pw $IN_FILE";      calc_pw "$IN_FILE"; }      || warn "calc_pw not defined" ;;
    dos)     have_func calc_dos     && { msg "→ calc_dos $IN_FILE";     calc_dos "$IN_FILE"; }     || warn "calc_dos not defined" ;;
    co)      have_func calc_co      && { msg "→ calc_co $IN_FILE";      calc_co "$IN_FILE"; }      || warn "calc_co not defined" ;;
    esp)     have_func calc_esp     && { msg "→ calc_esp $IN_FILE";     calc_esp "$IN_FILE"; }     || warn "calc_esp not defined" ;;
    hp)      have_func calc_hp      && { msg "→ calc_hp $IN_FILE";      calc_hp "$IN_FILE"; }      || warn "calc_hp not defined" ;;
    bands)   have_func calc_bands   && { msg "→ calc_bands $IN_FILE";   calc_bands "$IN_FILE"; }   || warn "calc_bands not defined" ;;
    w90)     have_func calc_w90     && { msg "→ calc_w90 $IN_FILE";     calc_w90 "$IN_FILE"; }     || warn "calc_w90 not defined" ;;
    phonon)  have_func calc_phonon  && { msg "→ calc_phonon $IN_FILE";  calc_phonon "$IN_FILE"; }  || warn "calc_phonon not defined" ;;
    thermo)  have_func calc_thermo  && { msg "→ calc_thermo $IN_FILE";  calc_thermo "$IN_FILE"; }  || warn "calc_thermo not defined" ;;
    dry)     have_func calc_dry     && { msg "→ calc_dry $IN_FILE";     calc_dry "$IN_FILE"; }     || warn "calc_dry not defined" ;;
    all)     for step in pw dos co esp bands; do run_qe "$step" "$IN_FILE"; done ;;
    *)       err "Unknown task: $task" ;;
  esac
}

calc_dry () {
    
    IN_FILE="$1"
    DRY_TEMP=${IN_FILE%.*}.dry.tmp
    DRY_OUT=${IN_FILE%.*}.dry.out

    cp $IN_FILE $DRY_TEMP

    if grep -q "^ *electron_maxstep *= *" "$DRY_TEMP"; then
        sed -i "s/^ *electron_maxstep *= .*/  electron_maxstep = 0/" "$DRY_TEMP"
    else
        sed -i "/&ELECTRONS/a\  electron_maxstep = 0" "$DRY_TEMP"
    fi 

    mpirun pw.x -in $DRY_TEMP |tee $DRY_OUT
    
    nelec=$(grep -m1 -e 'number of electrons' "$DRY_OUT" | awk -F'=' '{print int($NF)}')
    suggested_band=$(awk -v ne="$nelec" 'BEGIN { printf "%d", int(ne/2*1.25) + 4 }')
    nks_num=$(grep -m1 -e 'number of Kohn-Sham states' "$DRY_OUT" | awk -F'=' '{print int($NF)}')
    band_num=$(( nks_num >= suggested_band ? nks_num : suggested_band ))

    echo "Number of electrons:      $nelec"
    echo "Suggested NBANDS:         $suggested_band"
    echo "Kohn-Sham states (nks):   $nks_num"
    echo "Final NBANDS (band_num):  $band_num"

    cp $IN_FILE $IN_FILE.bak && rm $DRY_TEMP

    if grep -q "^ *nbnd *= *" "$IN_FILE"; then
        sed -i "s/^ *nbnd *= .*/  nbnd = $band_num/" "$IN_FILE"
    else
        sed -i "/ntyp/a\  nbnd = $band_num" "$IN_FILE"
    fi 
}

calc_pw () {
    IN_FILE="$1"
    mpirun pw.x -in $IN_FILE |tee ${IN_FILE%.*}.out
}

calc_dos () {

    IN_FILE="$1"

    if [[ ! -f ${IN_FILE%%.*}.dos.in ]]; then
        {
            echo "&DOS"
            grep -E "^\s*(prefix|outdir)\s*=" $IN_FILE
            echo "  degauss = 0.005"
            echo "/"
            echo "&PROJWFC"
            grep -E "^\s*(prefix|outdir)\s*=" $IN_FILE
            echo "  degauss = 0.005"
            echo "/"
        } > ${IN_FILE%%.*}.dos.in
    fi

    mpirun dos.x -in ${IN_FILE%%.*}.dos.in |tee ${IN_FILE%%.*}.dos.out
    mpirun projwfc.x -in ${IN_FILE%%.*}.dos.in |tee ${IN_FILE%%.*}.pdos.out

    for elem in $(grep "), wfc" ${IN_FILE%%.*}.pdos.out | awk -F'[()]' '{print $2}' | awk '{print $1}' | sort -u); do
        sumpdos.x *\($elem\)_* > ${IN_FILE%%.*}.pdos_$elem
    done

    mkdir -p ${IN_FILE%%.*}.pdos && mv ${IN_FILE%%.*}.pdos_* ${IN_FILE%%.*}.pdos/
}

calc_co () {

    IN_FILE="$1"

    if [[ ! -f ${IN_FILE%%.*}.pp_co.in ]]; then
        hoco_num=$(grep -m1 -e 'number of electrons' "${IN_FILE%.*}.out" | awk '{print int($NF/2)}')
        co_min=$((hoco_num - 2))
        co_max=$((hoco_num + 3))
        echo "HOCO number:    $hoco_num"
        {
            echo "&INPUTPP"
            grep -E "^\s*(prefix|outdir)\s*=" $IN_FILE
            echo "  filplot='${IN_FILE%%.*}.pp_co'"
            echo "  plot_num = 7"
            echo "  kpoint = 1"
            echo "  kband(1)= $co_min"
            echo "  kband(2)= $co_max"
            echo "  lsign = .true."
            echo "/"
            echo "&PLOT"
            echo "  iflag = 3"
            echo "  output_format = 6 "
            echo "  fileout = '.cube'"
            echo "/"
        } > ${IN_FILE%%.*}.pp_co.in
    fi

    mpirun pp.x -in ${IN_FILE%%.*}.pp_co.in |tee ${IN_FILE%%.*}.pp_co.out
    mkdir -p ${IN_FILE%%.*}.pp_co && mv ${IN_FILE%%.*}.pp_co_* ${IN_FILE%%.*}.pp_co/
}

calc_esp () {

    IN_FILE="$1"

    if [[ ! -f ${IN_FILE%%.*}.pp_esp.in ]]; then
        {
            echo "&INPUTPP"
            grep -E "^\s*(prefix|outdir)\s*=" $IN_FILE
            echo "  filplot='${IN_FILE%%.*}.pp_esp'"
            echo "  plot_num = 11"
            echo "/"
            echo "&PLOT"
            echo "  iflag = 3"
            echo "  output_format = 6"
            echo "  fileout = '${IN_FILE%%.*}.pp_esp.cube'"
            echo "  ! iflag = 1"
            echo "  ! output_format = 0"
            echo "  ! filepp(1)='${IN_FILE%%.*}.pp_esp'"
            echo "  ! fileout = '${IN_FILE%%.*}.pp_esp.gp'"
            echo "  ! e1(1) = 1.0, e1(2) = 0.0, e1(3) = 0"
            echo "  ! e2(1) = 0.0, e2(2) = 1.0, e2(3) = 0"
            echo "  ! e3(1) = 0.0, e3(2) = 0.0, e3(3) = 1.0"
            echo "  ! x0(1) = 0.5, x0(2) = 0.5, x0(3) = 0.5"
            echo "  ! nx = 100, ny = 100"
            echo "/"
        } > ${IN_FILE%%.*}.pp_esp.in
    fi

    mpirun pp.x -in ${IN_FILE%%.*}.pp_esp.in |tee ${IN_FILE%%.*}.pp_esp.out

}

calc_hp () {

    IN_FILE="$1"

    if [[ ! -f ${IN_FILE%%.*}.hp.in ]]; then
        {
            echo "&INPUTHP"
            grep -E "^\s*(prefix|outdir)\s*=" $IN_FILE
            echo "  nq1 = 1, nq2 = 1, nq3 = 1"
            echo "  conv_thr_chi = 1.0d-5"
            echo "  iverbosity = 2"
            echo "/"
        } > ${IN_FILE%%.*}.hp.in 
    fi

    mpirun hp.x -in ${IN_FILE%%.*}.hp.in |tee ${IN_FILE%%.*}.hp.out
}

# require .kpf dile
calc_bands () {
    
    IN_FILE="$1"
    BANDS_IN=${IN_FILE%%.*}.bands.in

    if [[ ! -f ${IN_FILE%%.*}.band.in ]]; then
        {
            echo "&BANDS"
            grep -E "^\s*(prefix|outdir)\s*=" $IN_FILE
            echo "  filband ='${IN_FILE%%.*}.band'"
            echo "  lsym = .false."
            echo "/"
        } > ${IN_FILE%%.*}.band.in
    fi

    if [[ ! -f ${IN_FILE%%.*}.band_plot.in ]]; then
        Efermi=$(grep "highest occupied" ${IN_FILE%.*}.out | awk -F'[:]' '{print $2}' | awk '{print $1}')
        Eband_min=$(echo "$Efermi - 10" | bc)
        Eband_max=$(echo "$Efermi + 10" | bc)
        {
            echo "${IN_FILE%%.*}.band"
            echo "$Eband_min, $Eband_max"
            echo "${IN_FILE%%.*}.band_plot.xmgr"
            echo "${IN_FILE%%.*}.band_plot.ps"
            echo "$Efermi eV"
            echo "2 $Efermi eV"
        } > ${IN_FILE%%.*}.band_plot.in
    fi

    if [[ ! -f $BANDS_IN ]]; then

        awk '
            /Real form of k-point coordinates/ {flag=1; next}
            /^#/ || NF==0 {next}
            flag {
                if ($1 ~ /^#/) next
                count++
                x[count] = $1
                y[count] = $2
                z[count] = $3
                label[count] = $4
            }
            /END of FILE/ {flag=0}
            END {
                print count
                interval = int(50 / count)
                for (i = 1; i <= count; i++) {
                    printf "   %.10f     %.10f     %.10f     %3d   ! %s\n", x[i], y[i], z[i], interval, label[i]
                }
            }
        ' "${IN_FILE%%.*}.kpf" > band_kps.tmp

        awk -v kpath_file="band_kps.tmp" '
            BEGIN {
                inserting = 0
                skip = 0
            }
            /^\s*calculation\s*=/ {
                print "  calculation = '\''bands'\''"
                next
            }
            /^K_POINTS/ {
                inserting = 1
                if ($2 == "automatic") skip = 1
                print "K_POINTS {crystal_b}"
                # Read and print the k-point path from the external file
                while ((getline line < kpath_file) > 0) print line
                close(kpath_file)
                next
            }
            skip {
                skip = 0
                next
            }
            {
                print
            }
        ' "$IN_FILE" > "$BANDS_IN" && rm band_kps.tmp
    fi

    mpirun pw.x -in $BANDS_IN |tee ${BANDS_IN%.*}.out
    mpirun bands.x -in ${IN_FILE%%.*}.band.in |tee ${IN_FILE%%.*}.band.out
    plotband.x < ${IN_FILE%%.*}.band_plot.in |tee ${IN_FILE%%.*}.band_plot.out
    mkdir -p ${IN_FILE%%.*}.band_plot && mv ${IN_FILE%%.*}.band_plot.* ${IN_FILE%%.*}.band_plot/

}

# require .kpf dile
calc_w90 () {

    IN_FILE=$1
    W90IN=${IN_FILE%%.*}.win

    if [[ ! -f ${IN_FILE%%.*}.open_grid.out ]]; then
        {
            echo "&INPUTPP"
            grep -E "^\s*(prefix|outdir)\s*=" $IN_FILE
            echo "/"
        } > ${IN_FILE%%.*}.open_grid.in

         mpirun open_grid.x -in ${IN_FILE%%.*}.open_grid.in |tee ${IN_FILE%%.*}.open_grid.out
    fi

    
    if [[ ! -f $W90IN ]]; then
        awk '
            /wannier90/ {flag=1; next}
            /OPEN_GRID    :/ {flag=0; next}
            flag && NF
        ' ${IN_FILE%%.*}.open_grid.out > w90_kpoints.tmp
        
        awk '
            /ATOMIC_POSITIONS/ {flag=1; next}
            /K_POINTS/ {flag=0; next}
            flag && NF
        ' $IN_FILE > w90_pos.tmp

        awk '
            $1 == "A" {
                a = $3
            }
            $1 == "CELL_PARAMETERS" {
                flag = 1
                next
            }
            $1 == "ATOMIC_SPECIES" {
                flag = 0
            }
            flag && NF {
                for (i = 1; i <= NF; i++) {
                    v[i] = $i * a
                }
                printf "   %.7f    %.7f    %.7f\n", v[1], v[2], v[3]
            }
        ' "$IN_FILE" > w90_cell.tmp

        awk '
            /Real form of k-point coordinates/ { flag = 1; next }
            /^#/ || NF == 0 { next }
            flag && $1 !~ /^#/ {
                labels[++count] = $NF
                coords[count] = sprintf("%.10f %.10f %.10f", $1, $2, $3)
            }
            /END of FILE/ { flag = 0 }
            END {
                for (i = 1; i < count; i++) {
                    printf "%-6s  %s    %-6s  %s\n", labels[i], coords[i], labels[i+1], coords[i+1]
                }
            }
        ' ${W90IN%.*}.kpf > w90_kpath.tmp

        mp_grid=$(awk '
                     tolower($0) ~ /^k_points/ && tolower($2) == "automatic" { getline; print $1, $2, $3 }
                ' "$IN_FILE")

        nbnd=$(grep -E "^\s*nbnd\s*=" "$IN_FILE" | awk -F'[=]' '{print int($NF)}')
        nwan=$(echo "scale=0; ($nbnd - 4)/1.86" | bc)
        hole=$(grep "highest occupied" ${IN_FILE%.*}.out | tail -n 1 | awk -F'[:]' '{print $2}' | awk '{print $1}')
        lule=$(grep "highest occupied" ${IN_FILE%.*}.out | tail -n 1 | awk -F'[:]' '{print $2}' | awk '{print $2}')
        Eband_min=$(echo "$hole - 10" | bc)
        Eband_max=$(echo "$lule + 10" | bc)
        Eband_froz_max=$(echo "scale=4; ($hole + $lule)/2" | bc)


        {
            echo "num_bands = $nbnd"
            echo "num_wann  = $nwan"
            # echo "exclude_bands = 1-12"
            echo "dis_win_min = $Eband_min"
            echo "dis_win_max = $Eband_max"
            echo "dis_froz_max = $Eband_froz_max"
            # echo "conv_window = 3"
            # echo "conv_tol = 1.0d-10"
            # echo "dis_num_iter = 200"
            # echo "num_iter = 100"
            echo "bands_plot = .true."
            echo "bands_num_points = 20"
            # echo "guiding_centres = .true."
            echo "auto_projections = .true."
            # echo ""
            # echo "begin projections"
            # echo "!random"
            # echo "O:px;py;pz"
            # echo "Ti:dz2;dx2-y2;dxz;dyz;dxy"
            # echo "end projections"
            echo ""
            echo "Begin Kpoint_Path"
            cat w90_kpath.tmp
            echo "End Kpoint_Path"
            echo ""
            echo "begin unit_cell_cart"
            echo "ang"
            cat w90_cell.tmp
            echo "end unit_cell_cart"
            echo ""
            echo "begin atoms_frac"
            cat w90_pos.tmp
            echo "end atoms_frac"
            echo ""
            echo "mp_grid: $mp_grid"
            echo "begin kpoints"
            cat w90_kpoints.tmp
            echo "end kpoints"
        } > $W90IN && rm w90_*.tmp
    fi

    if [[ ! -f ${IN_FILE%%.*}.pw2wan.in ]]; then
        {
            echo "&INPUTPP"
            grep -E "^\s*prefix\s*=" "$IN_FILE" | sed -E "s/(prefix\s*=\s*')([^']+)(')/\1\2_open\3/"
            grep -E "^\s*outdir\s*=" "$IN_FILE"
            echo "  seedname = '${W90IN%.*}'"
            # echo "  atom_proj = .true."
            echo "  scdm_proj = .true."
            echo "  scdm_entanglement = 'erfc'" 
            echo "  scdm_mu = 10"
            echo "  scdm_sigma = 4"
            echo "  write_unk = .false."
            echo "/"
        } > "${IN_FILE%%.*}.pw2wan.in"
    fi

    wannier90.x -pp $W90IN
    mpirun pw2wannier90.x -in ${IN_FILE%%.*}.pw2wan.in |tee ${IN_FILE%%.*}.pw2wan.out
    wannier90.x $W90IN
    # mkdir -p ${IN_FILE%%.*}.w90 && mv UNK*.1 ${IN_FILE%%.*}.w90/
    gnuplot -e "set terminal pdfcairo; set output '${W90IN%.*}_band.pdf'" ${W90IN%.*}_band.gnu 
}

calc_phonon () {

    IN_FILE="$1"
    PH_BASENAME=${IN_FILE%%.*}
    mp_grid=$(awk '
                tolower($0) ~ /^k_points/ && tolower($2) == "automatic" { getline; print $1, $2, $3 }
            ' "$IN_FILE")
    read nk1 nk2 nk3 <<< "$mp_grid"

    # if [[ ! -f $PH_BASENAME.d3hess.in ]]; then
    #     {
    #         echo "$PH_BASENAME"
    #         echo "&INPUTPH"
    #         grep -E "^\s*(prefix|outdir)\s*=" $IN_FILE
    #         echo "  filhess='$PH_BASENAME.hess'"
    #         echo "/"
    #     } > $PH_BASENAME.d3hess.in
    # fi

    if [[ ! -f $PH_BASENAME.ph.in ]]; then
        {
            echo "$PH_BASENAME"
            echo "&INPUTPH"
            grep -E "^\s*(prefix|outdir)\s*=" $IN_FILE
            echo "  ! dftd3_hess='$PH_BASENAME.hess'"
            echo "  fildyn='$PH_BASENAME.dyn'"
            echo "  tr2_ph = 1d-12"
            echo "  alpha_mix(1)=0.7"
            echo "  nmix_ph=4"
            echo "  ! recover = .true."
            echo "  ldisp=.true."
            echo "  nq1=$nk1, nq2=$nk2, nq3=$nk3"
            echo "/"
            echo "! 0 0 0"
        } > $PH_BASENAME.ph.in
    fi

    # if [[ ! -f $PH_BASENAME.dynmat.in ]]; then
    #     {
    #         echo "&INPUT"
    #         echo "  asr='crystal'"
    #         echo "  fildyn='$PH_BASENAME.dyn'"
    #         echo "  filout='$PH_BASENAME.dynmat.eig'"
    #         echo "  filmol='$PH_BASENAME.dynmat.molden'"
    #         echo "  filxsf='$PH_BASENAME.dynmat.axsf'"
    #         echo "/"
    #     } > $PH_BASENAME.dynmat.in
    # fi

    if [[ ! -f $PH_BASENAME.q2r.in ]]; then
        {
            echo "&INPUT"
            echo "  zasr='crystal'"
            echo "  fildyn='$PH_BASENAME.dyn'"
            echo "  flfrc='$PH_BASENAME.fc'"
            echo "/"
        } > $PH_BASENAME.q2r.in
    fi

    if [[ ! -f $PH_BASENAME.matdyn.in ]]; then
        {
            echo "&INPUT"
            echo "  flfrc='$PH_BASENAME.fc'"
            echo "  flfrq='$PH_BASENAME.matdyn.freq'"
            echo "  flvec='$PH_BASENAME.matdyn.modes'"
            echo "  fleig='$PH_BASENAME.matdyn.eig'"
            echo "  dos   = .true."
            echo "  fldos = '$PH_BASENAME.matdyn.dos'"
            echo "  nk1 = $nk1, nk2 = $nk2, nk3 = $nk3"
            echo "  ! q_in_band_form=.true."
            echo "/"
            echo "! 1"
            echo "! 0 0 0 1"
            echo "! 0 0 0 0"
        } > $PH_BASENAME.matdyn.in
    fi

    # mpirun d3hess.x -in $PH_BASENAME.d3hess.in |tee $PH_BASENAME.d3hess.out
    mpirun ph.x -in $PH_BASENAME.ph.in |tee $PH_BASENAME.ph.out
    # mpirun dynmat.x -in $PH_BASENAME.dynmat.in |tee $PH_BASENAME.dynmat.out
    mpirun q2r.x -in $PH_BASENAME.q2r.in |tee $PH_BASENAME.q2r.out
    mpirun matdyn.x -in $PH_BASENAME.matdyn.in |tee $PH_BASENAME.matdyn.out

}

calc_thermo () {
    IN_FILE="$1"
    PH_BASENAME=${IN_FILE%%.*}
    if [[ ! -f thermo_control ]]; then
        {
            echo "&INPUT_THERMO"
            echo "  what='scf_disp'"
            echo "  find_ibrav=.TRUE."
            echo "  nq1_d=192"
            echo "  nq2_d=192"
            echo "  nq3_d=192"
            echo "/"
        } > thermo_control
    fi

    if [[ ! -f ph_control ]]; then
        {
            echo ""
            echo "&inputph"
            echo "  tr2_ph=1.0d-12"
            echo "  prefix='$PH_BASENAME'"
            echo "  fildyn='$PH_BASENAME.dyn.xml'"
            echo "  ldisp=.TRUE."
            echo "  nq1=1, nq2=1, nq3=1,"
            echo "  alpha_mix(1)=0.7"
            echo "  nmix_ph=4"
            echo "/"
        } > ph_control
    fi

    mpirun thermo_pw.x < $PH_BASENAME.scf.in > $PH_BASENAME.scf.out
}

# ---------- Main ----------
if [[ $# -eq 0 ]]; then
  print_help; exit 0
fi

for a in "$@"; do
  [[ "$a" == "-h" || "$a" == "--help" ]] && { print_help; exit 0; }
done

IN_FILE=$1; shift || true
[[ -f "$IN_FILE" ]] || err "Input file not found: $IN_FILE"

if [[ $# -eq 0 ]]; then
  msg "No task specified → default to pw"
  run_qe pw "$IN_FILE"
  exit 0
fi

msg "Input: $IN_FILE"
msg "Tasks: $*"
for t in "$@"; do
  run_qe "$t" "$IN_FILE"
done

msg "All requested tasks finished."